#!/usr/bin/env bash
# -*- coding: utf-8 -*-
# shellcheck shell=bash disable=SC1091,SC2039,SC2166,SC2034
#
#  pkgmake — makepkg-like tool for XBPS
#  Created: dom 21 dez 2025 11:47:51 -04
#  Altered: dom 21 dez 2025 11:47:51 -04
#  Updated: dom 21 dez 2025 11:47:51 -04
#
#  Copyright (c) 2019-2025, Vilmar Catafesta <vcatafesta@gmail.com>
#  Assembled By Vilmar Catafesta for the ChiliLinux project.
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY Vilmar Catafesta ''AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##############################################################################
#export LANGUAGE=pt_BR
export TEXTDOMAINDIR=/usr/share/locale
export TEXTDOMAIN=pkgmake

#debug
export PS4='${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset}'
#set -x
set -e

#system
declare APP="${0##*/}"
declare _VERSION_="0.12.21-20251221"
declare APPDESC="$APP - Wraper for xbps-create"
declare distro="$(uname -n)"
declare DEPENDENCIES=(tput)

WORKDIR="$PWD"
SRCDIR="$WORKDIR/src"
PKGDIR="$WORKDIR/pkg"
ARCH="$(uname -m)"

SYNCDEPS=0
INSTALLPKG=0
FORCEPKG=0
PRIVKEY=""
SIGNPKG=0
CLI_SIGNPKG=""
SIGN_ONLY=0
VERBOSE=0
CLI_VERBOSE=""
GEN_KEY=0
KEY_FILE="privkey.pem"
PRINTCONFIG=0
PKGDEST=""
CLI_PKGDEST=""

# ANSI colors
reset='\033[0m'
black='\033[0;30m'
red='\033[0;31m'
green='\033[0;32m'
yellow='\033[0;33m'
blue='\033[0;34m'
magenta='\033[0;35m'
cyan='\033[0;36m'
white='\033[0;37m'

# Bold
bold='\033[1m'
bold_black='\033[1;30m'
bold_red='\033[1;31m'
bold_green='\033[1;32m'
bold_yellow='\033[1;33m'
bold_blue='\033[1;34m'
bold_magenta='\033[1;35m'
bold_cyan='\033[1;36m'
bold_white='\033[1;37m'

# Backgrounds
bg_black='\033[40m'
bg_red='\033[41m'
bg_green='\033[42m'
bg_yellow='\033[43m'
bg_blue='\033[44m'
bg_magenta='\033[45m'
bg_cyan='\033[46m'
bg_white='\033[47m'

parse_config() {
	# Load global config
	set +e
	[[ -f /etc/pkgmake.conf ]] && source /etc/pkgmake.conf
   ret=$?
   set -e
   ((ret == 0)) || die "erro ao carregar PKGFILE"
}

validate_config() {
	# SIGNPKG
	[[ "$SIGNPKG" =~ ^[01]$ ]] || die "SIGNPKG inválido (use 0 ou 1)"

	# VERBOSE
	[[ "$VERBOSE" =~ ^[01]$ ]] || die "VERBOSE inválido (use 0 ou 1)"

	# PACKAGER (se definido)
	if [[ -n "$PACKAGER" ]]; then
		[[ "$PACKAGER" == *"<"*">"* ]] ||
			die "PACKAGER inválido (esperado: Nome <email>)"
	fi

	# Assinatura
	if [[ "$SIGNPKG" -eq 1 ]]; then
		if [[ -n "$PRIVKEY" ]]; then
			[[ -f "$PRIVKEY" ]] ||
				die "PRIVKEY definido, mas chave não encontrada: $PRIVKEY"
		else
			find_privkey || die "SIGNPKG=1, mas nenhuma chave privada encontrada"
		fi
	fi
}

validate_pkgdest_sanity() {
	case "$PKGDEST" in
	*::* | *"//"*)
		die "PKGDEST inválido: $PKGDEST"
		;;
	esac
}

cmd_run() {
	if [[ "$VERBOSE" -eq 0 ]]; then
		"$@" >/dev/null 2>&1
	else
		"$@"
	fi
}

die() {
	echo -e "${red}erro: $*${reset}" >&2
	exit 1
}
msg() { echo -e "${cyan}==> $*${reset}"; }
warn() { echo -e "${yellow}==> aviso: $*${reset}" >&2; }

print_config() {
	cat <<EOF
# pkgmake effective configuration

PKGDEST=${PKGDEST:-"(default: ./repo)"}
PACKAGER=${PACKAGER:-"(not set)"}

SYNCDEPS=${SYNCDEPS:-0}
CLEANUP=${CLEANUP:-0}

SIGNPKG=${SIGNPKG:-0}
PRIVKEY=${PRIVKEY:-"(auto-detect)"}

REINDEX_FORCE=${REINDEX_FORCE:-1}

VERBOSE=${VERBOSE:-0}
EOF
}

gen_key() {
	[[ -f "$KEY_FILE" ]] && die "chave já existe: $KEY_FILE"

	msg "Gerando chave RSA 4096 bits (PEM): $KEY_FILE"
	cmd_run ssh-keygen -t rsa -b 4096 -m PEM -f "$KEY_FILE"

	msg "Chave gerada com sucesso:"
	msg "  $KEY_FILE"
}

normalize_dep_patterns() {
	local var i dep
	for var in depends makedepends; do
		declare -p "$var" &>/dev/null || continue
		declare -n arr="$var"
		for i in "${!arr[@]}"; do
			dep="${arr[$i]}"
			# se NÃO contém operador de versão (<, > ou =), adiciona >=0
			if ! [[ "$dep" =~ [\<\>\=] ]]; then
				arr[$i]="${dep}>=0"
			fi
		done
	done
}

normalize_deps() {
	# depends
	if declare -p depends &>/dev/null; then
		if [[ "$(declare -p depends)" != declare\ -a* ]]; then
			depends="${depends//$'\n'/ }"
			read -r -a depends <<<"$depends"
		fi
	else
		depends=()
	fi

	# makedepends
	if declare -p makedepends &>/dev/null; then
		if [[ "$(declare -p makedepends)" != declare\ -a* ]]; then
			makedepends="${makedepends//$'\n'/ }"
			read -r -a makedepends <<<"$makedepends"
		fi
	else
		makedepends=()
	fi
}

load_pkgfile() {
	[[ -f PKGFILE ]] || die "PKGFILE não encontrado"
	source ./PKGFILE

	: "${pkgname:?}"
	: "${pkgver:?}"
	: "${pkgrel:?}"
	: "${pkgdesc:?}"
	: "${license:?}"

	pkgbase="${pkgbase:-$pkgname}"
	declare -p source &>/dev/null || die "source não definido"
	HAS_GIT_SOURCE=0
	for s in "${source[@]}"; do
      [[ "$s" == *git+* ]] && HAS_GIT_SOURCE=1 || true
	done
}

lint() {
	declare -f package >/dev/null || die "função package() ausente"

	# Detecta PKGFILE que apaga o source (incompatível com pkgmake)
	if grep -Eq 'rm[[:space:]]+-rf[[:space:]]+(\$|\$\{)(_pkgsrc|srcdir|pkgbase)|rm[[:space:]]+-rf[[:space:]]+["'\'']?\$\{?pkgbase\}?-\$\{?pkgver\}?' PKGFILE; then
		die "PKGFILE inválido: não use 'rm -rf' no diretório de source (incompatível com pkgmake)"
	fi
}

sync_deps() {
	[[ "$SYNCDEPS" -eq 1 ]] || return 0
	local pkgs=()
	[[ -n "${makedepends[*]}" ]] && pkgs+=("${makedepends[@]}")
	[[ -n "${depends[*]}" ]] && pkgs+=("${depends[@]}")
	[[ "${#pkgs[@]}" -eq 0 ]] && return 0
	sudo xbps-install -Sy "${pkgs[@]}"
}

fetch() {
  msg "Fetch source"
  mkdir -p "$SRCDIR"
  cd "$SRCDIR"

  for src in "${source[@]}"; do
    # alias::source
    if [[ "$src" == *::* ]]; then
      name="${src%%::*}"
      s="${src#*::}"
    else
      name=""
      s="$src"
    fi

    case "$s" in
      git+*)
        repo="${s#git+}"

        tag=""
        if [[ "$repo" == *#tag=* ]]; then
          tag="${repo##*#tag=}"
          repo="${repo%%#tag=*}"
        fi

        # se não tiver alias, usa basename
        [[ -z "$name" ]] && name="$(basename "$repo" .git)"

        if [[ -d "$name/.git" ]]; then
          msg "Usando repositório git existente: $name"
        else
          cmd_run git clone "$repo" "$name" || die "falha ao clonar $repo"
        fi

        if [[ -n "$tag" ]]; then
          cmd_run git -C "$name" checkout "$tag" \
            || die "falha ao fazer checkout do tag $tag"
        fi
        ;;
      http://*|https://*)
        f="${s##*/}"
        if [[ -f "$f" ]]; then
          msg "Source já existe, usando cache: $f"
        else
          if ! cmd_run curl -fL --output "./$f" -- "$s"; then
            case "$f" in
              *.asc|*.sig)
                warn "assinatura não encontrada ($f), ignorando"
                ;;
              *)
                die "falha ao baixar source obrigatório: $f"
                ;;
            esac
          fi
        fi
        ;;
      *)
        [[ -f "$WORKDIR/$s" ]] || die "arquivo local não encontrado: $s"
        cp -f "$WORKDIR/$s" .
        ;;
    esac
  done
}

extract() {
	msg "Extract source"
	cd "$SRCDIR"

	local extracted=0
	shopt -s nullglob

	for f in *.tar *.tar.gz *.tgz *.tar.xz *.tar.bz2 *.tar.zst; do
		case "$f" in
		*.tar.gz | *.tgz)
			cmd_run tar -xzf "$f" && extracted=1 || die "falha ao extrair $f"
			;;
		*.tar.xz)
			cmd_run tar -xJf "$f" && extracted=1 || die "falha ao extrair $f"
			;;
		*.tar.bz2)
			cmd_run tar -xjf "$f" && extracted=1 || die "falha ao extrair $f"
			;;
		*.tar.zst)
			cmd_run tar --zstd -xf "$f" && extracted=1 || die "falha ao extrair $f"
			;;
		*.tar)
			cmd_run tar -xf "$f" && extracted=1 || die "falha ao extrair $f"
			;;
		esac
	done

	shopt -u nullglob

	if [[ "$HAS_GIT_SOURCE" -eq 1 ]]; then
		msg "Fonte VCS detectada, pulando extração de tarball"
		return 0
	fi

   # se tiver fonte git, não exige tarball
   ((extracted)) || [[ "$HAS_GIT_SOURCE" -eq 1 ]] || die "nenhum tarball foi extraído"
}

detect_src() {
	local d

	d="$(find "$SRCDIR" -mindepth 1 -maxdepth 1 -type d | head -n1)"
	[[ -n "$d" ]] || die "diretório source não encontrado após extração"

	export srcdir="$SRCDIR"
	export _pkgsrc="$d"

	# compatibilidade total: Arch (pkgdir) == Void (DESTDIR)
	export pkgdir="$PKGDIR"
	export DESTDIR="$PKGDIR"
}

find_privkey() {
	[[ -n "$PRIVKEY" ]] && return 0
	for k in "$HOME/.gnupg/privkey.pem" "$HOME/.gnupg/private.pem"; do
		[[ -f "$k" ]] && {
			PRIVKEY="$k"
			return 0
		}
	done
	die "chave privada não encontrada"
}

run_all() {
	if [[ "$GEN_KEY" -eq 1 ]]; then
		gen_key
		exit 0
	fi

	if ((SIGN_ONLY)); then
		sign_only
		create_repodata
		exit 0
	fi

	msg "Lint"
	lint

	sync_deps

	fetch
	extract
	detect_src

	# estilo makepkg/xbps-src: cwd em srcdir
	cd "$srcdir" || die "falha ao entrar em srcdir"

	if declare -f prepare >/dev/null; then
		msg "Prepare"
		prepare
	fi

	if declare -f build >/dev/null; then
		msg "Build"
		build
	fi

	msg "Package"

	# staging único e seguro (Arch + Void)
	mkdir -p "$DESTDIR"
	[[ -n "$DESTDIR" && "$DESTDIR" != "/" ]] || die "DESTDIR inválido"

	package

	#   for d in "${depends[@]}"; do
	#    pkg="${d%%[<>=]*}"
	#    xbps-query -R -p pkgname "$pkg" >/dev/null || die "dependência inválida ou inexistente: $d"
	#   done

	# depends já é array aqui (graças ao normalize_deps)
	deps_list="${depends[*]}"

	msg "Create XBPS"
	cmd_run xbps-create \
		-A "$ARCH" \
		-n "${pkgname}-${pkgver}_${pkgrel}" \
		-s "$pkgdesc" \
		-l "$license" \
		-D "$deps_list" \
		"$pkgdir"

	PKGOUT="${pkgname}-${pkgver}_${pkgrel}.${ARCH}.xbps"
	mv -f "$PKGOUT" "$PKGDEST/"

	if ((SIGNPKG)); then
		sign_only
	fi

	create_repodata

	if [ "$INSTALLPKG" -eq 1 ]; then
		msg "Install package"
		if [[ "$FORCEPKG" -eq 1 ]]; then
			sudo xbps-install -R "$PKGDEST" -S -f "$pkgname"
		else
			sudo xbps-install -R "$PKGDEST" -S "$pkgname"
		fi
	else
		msg "Install with:"
		msg "  sudo xbps-install -R $PKGDEST -S ${pkgname}"
	fi

}

clean() {
	rm -rf "$SRCDIR" "$PKGDIR" "$PKGDEST"
}

usage() {
	printf "%b\n" \
		"${bold_blue}pkgmake${reset} — utilitário de build para pacotes XBPS

${bold}Uso:${reset}
  pkgmake [opções]

${bold}Opções:${reset}
  ${green}-s${reset}, ${green}--syncdeps${reset}               Instalar depends e makedepends
  ${green}-i${reset}, ${green}--install${reset}                Instalar pacote após o build
  ${green}-f${reset}, ${green}--force${reset}                  Forçar reinstalação do pacote
  ${green}-q${reset}, ${green}--quiet${reset}                  Silenciar saída dos comandos
  ${green}-v${reset}, ${green}--verbose${reset}                Mostrar saída dos comandos
      ${green}--sign${reset}                   Assinar pacote após o build
      ${green}--sign-only${reset}              Somente assinar pacotes existentes no repo
      ${green}--privkey${reset} ${yellow}<path>${reset}         Caminho da chave privada PEM (autodetecta se omitido)
      ${green}--gen-key${reset}                Gerar chave RSA 4096 em formato PEM
  ${green}-c|--clean${reset}                   Limpar diretórios de trabalho
  ${green}-p|--print-config${reset}            Imprimir configuracao do /etc/pkgmake.conf
  ${green}-k|--pkgdest${reset} ${yellow}<path>${reset}          Diretório local onde os pacotes (.xbps) e o repodata serão gerados
  ${green}-h${reset}, ${green}--help${reset}                   Mostrar este ajuda

${bold}Exemplos:${reset}
  pkgmake
  pkgmake -s -i
  pkgmake --sign
  pkgmake --sign-only --privkey minha-chave.pem
  pkgmake -q

"
}

create_repodataOLD() {
	msg "Recreate repodata : $PKGDEST/x86_64-repodata"
	cmd_run xbps-rindex -r "$PKGDEST"
	cmd_run xbps-rindex -a "$PKGDEST"/*.xbps
}

create_repodata() {
	msg "Recreate repodata (hard reset)"

	# remove TODO estado antigo
	rm -f "$PKGDEST"/*-repodata

	# recria índice vazio
	cmd_run xbps-rindex -r "$PKGDEST"

	# adiciona pacotes UM A UM (igual xbps-src)
	local p
	for p in "$PKGDEST"/*.xbps; do
		[[ -f "$p" ]] || continue
		cmd_run xbps-rindex -a "$p"
	done

	# assina o índice (se habilitado)
	if [[ "$SIGNPKG" -eq 1 ]]; then
		if [[ -n "$PRIVKEY" ]]; then
			if [[ ! -f "$PRIVKEY" ]]; then
				die "PRIVKEY definido, mas chave não encontrada: $PRIVKEY"
			fi
		else
			find_privkey || die "Nenhuma chave privada encontrada para assinatura"
		fi

		local signedby=()
		[[ -n "$PACKAGER" ]] && signedby=(--signedby "$PACKAGER")

		cmd_run xbps-rindex \
			--sign \
			"${signedby[@]}" \
			--privkey "$PRIVKEY" \
			"$PKGDEST"
	fi
}

sign_only() {
	if [[ -n "$PRIVKEY" ]]; then
		[[ ! -f "$PRIVKEY" ]] && die "PRIVKEY definido, mas chave não encontrada: $PRIVKEY"
	else
		find_privkey || die "Nenhuma chave privada encontrada para assinatura"
	fi

	shopt -s nullglob
	local pkgs=("$PKGDEST"/*.xbps)
	shopt -u nullglob

	[[ "${#pkgs[@]}" -gt 0 ]] || die "nenhum pacote .xbps encontrado em $PKGDEST"

	for pkg in "${pkgs[@]}"; do
		msg "Sign package: $(basename "$pkg")"
		rm -f "$pkg.sig2"
		cmd_run xbps-rindex --sign-pkg --privkey "$PRIVKEY" "$pkg"
	done
}

resolve_fns() {
	# prepare
	if ! declare -f prepare >/dev/null && declare -f do_prepare >/dev/null; then
		prepare() { do_prepare "$@"; }
	fi

	# build
	if ! declare -f build >/dev/null && declare -f do_build >/dev/null; then
		build() { do_build "$@"; }
	fi

	# package / install
	if ! declare -f package >/dev/null && declare -f do_install >/dev/null; then
		package() { do_install "$@"; }
	fi
}

resolve_pkgdest() {
	local dest

	if [[ -n "$CLI_PKGDEST" ]]; then
		dest="$CLI_PKGDEST"
	elif [[ -n "$PKGDEST" ]]; then
		dest="$PKGDEST"
	else
		die "PKGDEST não definido (use --pkgdest ou /etc/pkgmake.conf)"
	fi

	validate_pkgdest_sanity

	# absolutiza
	dest="$(readlink -f "$dest" 2>/dev/null || true)"
	[[ -n "$dest" ]] || die "PKGDEST inválido após resolução"

	# cria se não existir
	mkdir -p "$dest" || die "não consegui criar PKGDEST: $dest"

	# testa escrita
	[[ -w "$dest" ]] || die "sem permissão de escrita em PKGDEST: $dest"

	PKGDEST="$dest"
}

resolve_signpkg() {
	if [[ -n "$CLI_SIGNPKG" ]]; then
		SIGNPKG="$CLI_SIGNPKG"
	fi

	case "$SIGNPKG" in
	0 | 1) : ;;
	*)
		die "SIGNPKG inválido (use 0 ou 1): $SIGNPKG"
		;;
	esac
}

resolve_verbose() {
	if [[ -n "$CLI_VERBOSE" ]]; then
		VERBOSE="$CLI_VERBOSE"
	fi

	case "$VERBOSE" in
	0 | 1) : ;;
	*)
		die "VERBOSE inválido (use 0 ou 1): $VERBOSE"
		;;
	esac
}

while [[ $# -gt 0 ]]; do
	case "$1" in
	-s | --syncdeps)
		SYNCDEPS=1
		shift
		;;
	-i | --install)
		INSTALLPKG=1
		shift
		;;
	-f | --force)
		FORCEPKG=1
		shift
		;;
	-v | --verbose)
		CLI_VERBOSE=1
		shift
		;;
	-q | --quiet)
		CLI_VERBOSE=0
		shift
		;;
	--gen-key)
		GEN_KEY=1
		shift
		;;
	--sign)
		CLI_SIGNPKG=1
		shift
		;;
	--sign-only)
		SIGN_ONLY=1
		shift
		;;
	--privkey)
		PRIVKEY="$2"
		shift 2
		;;
	-c | --clean)
		clean
		exit 0
		;;
	-p | --print-config)
		print_config
		exit 0
		;;
	-k | --pkgdest)
		CLI_PKGDEST="$2"
		shift 2
		;;
	-h | --help)
		usage
		exit 0
		;;
	*) die "opção inválida: $1" ;;
	esac
done

parse_config
resolve_signpkg
resolve_verbose
resolve_pkgdest # blindagem de path + permissão (ANTES de tudo)
load_pkgfile
normalize_deps
normalize_dep_patterns
resolve_fns
validate_config # validação FINAL, com tudo resolvido
run_all
