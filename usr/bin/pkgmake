#!/usr/bin/env bash
# -*- coding: utf-8 -*-
# shellcheck shell=bash disable=SC1091,SC2039,SC2166,SC2034
#
#  pkgmake — makepkg-like tool for XBPS
#  Created: dom 21 dez 2025 11:47:51 -04
#  Altered: dom 21 dez 2025 11:47:51 -04
#  Updated: ter 23 dez 2025 00:21:48 -03
#
#  Copyright (c) 2019-2025, Vilmar Catafesta <vcatafesta@gmail.com>
#  Assembled By Vilmar Catafesta for the ChiliLinux project.
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY Vilmar Catafesta ''AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##############################################################################
#export LANGUAGE=pt_BR
export TEXTDOMAINDIR=/usr/share/locale
export TEXTDOMAIN=pkgmake

#debug
export PS4='${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset}'
#set -x
set -e

#system
declare APP="${0##*/}"
declare _VERSION_="0.12.21-20251221"
declare APPDESC="$APP - Wraper for xbps-create"
declare distro="$(uname -n)"
declare DEPENDENCIES=(tput)

WORKDIR="$PWD"
SRCDIR="$WORKDIR/src"
PKGDIR="$WORKDIR/pkg"
ARCH="$(uname -m)"

SYNCDEPS=0
CLI_SYNCDEPS=""
INSTALLPKG=0
FORCEPKG=0
PRIVKEY=""
SIGNPKG=0
CLI_SIGNPKG=""
SIGN_ONLY=0
VERBOSE=0
CLI_VERBOSE=""
GEN_KEY=0
KEY_FILE="privkey.pem"
PRINTCONFIG=0
PKGDEST=""
CLI_PKGDEST=""
# Sites globais (compatibilidade xbps-src)
DEBIAN_SITE="https://deb.debian.org/debian"

# Colors: prefer tput, fallback to ANSI
if command -v tput >/dev/null 2>&1 && tput sgr0 >/dev/null 2>&1; then
	reset="$(tput sgr0)"
	rst="$(tput sgr0)"
	bold="$(tput bold)"

	black="$(tput setaf 0)"
	red="$(tput setaf 1)"
	green="$(tput setaf 2)"
	yellow="$(tput setaf 3)"
	blue="$(tput setaf 4)"
	magenta="$(tput setaf 5)"
	cyan="$(tput setaf 6)"
	white="$(tput setaf 7)"
else
	# ANSI colors
	reset='\033[0m'
	rst='\033[0m'
	black='\033[0;30m'
	red='\033[0;31m'
	green='\033[0;32m'
	yellow='\033[0;33m'
	blue='\033[0;34m'
	magenta='\033[0;35m'
	cyan='\033[0;36m'
	white='\033[0;37m'
	bold='\033[1m'
fi

validate_pkgname() {
	local name="$1"

	[[ -z "$name" ]] && return 1
	if [[ ! "$name" =~ ^[A-Za-z0-9][A-Za-z0-9._-]*$ ]]; then
		return 1
	fi
	return 0
}

pkgmake_new() {
	# pkgmake new — create PKGFILE skeleton or import from Arch/Void
	local PKGNAME=""
	local MODE="skeleton"
	local DIRPKGFILE='local'
	# -------- argumentos --------
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--from-arch)
			MODE="arch"
			shift
			;;
		--from-voidlinuxbr)
			MODE="voidlinuxbr"
			shift
			;;
		--from-void)
			MODE="void"
			shift
			;;
		-*)
			die "opção inválida: $1"
			;;
		*)
			PKGNAME="$1"
			shift
			;;
		esac
	done

	[[ -z "$PKGNAME" ]] &&
		die "nome do pacote não informado"

	validate_pkgname "$PKGNAME" ||
		die "nome de pacote inválido: '$PKGNAME' (use apenas letras, números, '.', '_' ou '-')"

	[[ "$MODE" != "skeleton" ]] && DIRPKGFILE="$MODE"
	DIRPKGFILE+="-${PKGNAME}"
	[[ -e "${DIRPKGFILE}" ]] &&
		die "diretório '$DIRPKGFILE' já existe"

	case "$MODE" in
	arch)
		from_arch "$PKGNAME" "${DIRPKGFILE}"
		;;
	voidlinuxbr)
		from_voidlinuxbr "$PKGNAME" "${DIRPKGFILE}"
		;;
	void)
		from_void "$PKGNAME" "${DIRPKGFILE}"
		;;
	skeleton)
		from_skeleton "$PKGNAME" "${DIRPKGFILE}"
		;;
	*)
		die "modo interno inválido"
		;;
	esac
}

from_skeleton() {
	local PKGNAME="$1"
	local DIRPKGFILE="$2"

	mkdir -p "${DIRPKGFILE}" || die "não foi possível criar diretório '${DIRPKGFILE} '"
	cd "${DIRPKGFILE}" || die "não foi possível entrar no diretório '${DIRPKGFILE} '"

	cat >PKGFILE <<EOF
#!/usr/bin/env bash
# Maintainer: $(whoami)
#
# PKGFILE skeleton
# Generated by pkgmake new
#
# NOTE: This PKGFILE MUST be reviewed and completed before use

pkgname=$PKGNAME
pkgver=0.1.0
pkgrel=1
pkgdesc=""
license=()
homepage=""
depends=()
makedepends=()
distfiles=()
checksum=()

prepare() {
  :
}

build() {
  :
}

package() {
  :
}
EOF

	cd - >/dev/null || true

	msg "PKGFILE criado com sucesso."
	msg "Entre no diretório com: cd $DIRPKGFILE"
	msg "Revisão manual obrigatória."
}

from_voidlinuxbr() {
	local PKGNAME="$1"
	local DIRPKGFILE="$2"
	local REPO_URL="https://raw.githubusercontent.com/voidlinuxbr/pkgmake/main"
	local TMP
	TMP="$(mktemp -d)"

	msg "Importando template VoidLinuxBR: $PKGNAME"
	msg "Fonte: https://github.com/voidlinuxbr/pkgmake"

	# Escolhe downloader
	if command -v curl >/dev/null 2>&1; then
		DL="curl -fsSL"
	elif command -v wget >/dev/null 2>&1; then
		DL="wget -qO-"
	else
		die "necessário 'curl' ou 'wget' para download"
	fi

	# Baixa template do VoidLinuxBR
	if ! $DL "$REPO_URL/templates/$PKGNAME/PKGFILE" >"$TMP/PKGFILE" 2>/dev/null; then
		rm -rf "$TMP"
		die "template VoidLinuxBR não encontrado para pacote '$PKGNAME'"
	fi

	# Cria diretório do pacote
	mkdir -p "${DIRPKGFILE}"
	cd "${DIRPKGFILE}" || die "não foi possível entrar no diretório '${DIRPKGFILE} '"

	# Gera PKGFILE com aviso explícito
	{
		cat "$TMP/PKGFILE"
	} >PKGFILE

	cd - >/dev/null || true
	rm -rf "$TMP"

	msg "PKGFILE criado com sucesso."
	msg "Entre no diretório com: cd $DIRPKGFILE"
	msg "Revisão manual obrigatória."
}

# -------------------------------------------------------------------
# new --from-arch <pkgname>
# Importa template oficial do Arch Linux
# -------------------------------------------------------------------
from_arch() {
	local PKGNAME="$1"
	local DIRPKGFILE="$2"

	mkdir -p "${DIRPKGFILE}"
	cd "${DIRPKGFILE}"

	msg "Fetch PKGBUILD from Arch/AUR"

	TMP="$(mktemp -d)"
	trap 'rm -rf "$TMP"' EXIT

	if ! curl -fsSL \
		"https://gitlab.archlinux.org/archlinux/packaging/packages/$PKGNAME/-/raw/main/PKGBUILD" \
		-o "$TMP/PKGBUILD"; then
		curl -fsSL \
			"https://aur.archlinux.org/cgit/aur.git/plain/PKGBUILD?h=$PKGNAME" \
			-o "$TMP/PKGBUILD" || die "PKGBUILD não encontrado"
	fi

	# -------------------------------------------------
	# GERA PKGFILE (SEM MUTILAR source)
	# -------------------------------------------------
	{
		echo "#!/usr/bin/env bash"
		echo "# NOTE: Imported from Arch PKGBUILD"
		echo "# NOTE: This PKGFILE is PARTIAL and MUST be reviewed"
		echo

		# remove linhas que quebram execução fora do makepkg
		sed \
			-e '/^pkgbase=/d' \
			-e '/^validpgpkeys=/d' \
			-e '/^_.*=/d' \
			"$TMP/PKGBUILD"
	} >PKGFILE
	msg "PKGFILE criado com sucesso."
	msg "Entre no diretório com: cd ${DIRPKGFILE} "
	msg "Revisão manual obrigatória."
	exit 0
}

# -------------------------------------------------------------------
# new --from-void <pkgname>
# Importa template oficial do Void Linux (void-packages)
# -------------------------------------------------------------------
from_void() {
	local pkg="$1"
	local DIRPKGFILE="$2"
	local VOID_REPO="https://raw.githubusercontent.com/void-linux/void-packages/master"
	local TMP
	TMP="$(mktemp -d)"

	[[ -z "$pkg" ]] && die "nome do pacote não informado"

	msg "Importando template do Void Linux: $pkg"
	msg "Fonte: void-linux/void-packages"

	# Escolhe downloader
	if command -v curl >/dev/null 2>&1; then
		DL="curl -fsSL"
	elif command -v wget >/dev/null 2>&1; then
		DL="wget -qO-"
	else
		die "necessário 'curl' ou 'wget' para download"
	fi

	# Baixa template oficial (obrigatório)
	if ! $DL "$VOID_REPO/srcpkgs/$pkg/template" >"$TMP/template" 2>/dev/null; then
		rm -rf "$TMP"
		die "template do Void não encontrado para pacote '$pkg'"
	fi

	# Tenta baixar INSTALL (opcional)
	if $DL "$VOID_REPO/srcpkgs/$pkg/INSTALL" >"$TMP/INSTALL" 2>/dev/null; then
		HAS_INSTALL=1
	else
		HAS_INSTALL=0
	fi

	# Cria diretório do pacote
	mkdir -p "${DIRPKGFILE}"
	cd "${DIRPKGFILE}" || die "não foi possível entrar no diretório '${DIRPKGFILE}'"

	# Gera PKGFILE com aviso explícito
	{
		echo "#!/usr/bin/env bash"
		echo "# NOTE: Imported from Void Linux official template"
		echo "# NOTE: Source: https://github.com/void-linux/void-packages"
		echo "# NOTE: This PKGFILE MUST be reviewed and adjusted before use"
		echo
		cat "$TMP/template"
	} >PKGFILE

	chmod +x PKGFILE

	# Copia INSTALL se existir
	if ((HAS_INSTALL)); then
		cp "$TMP/INSTALL" INSTALL
		chmod +x INSTALL
		msg "INSTALL importado."
	fi

	cd - >/dev/null || true
	rm -rf "$TMP"

	msg "PKGFILE criado com sucesso."
	((HAS_INSTALL)) && msg "INSTALL criado com sucesso."
	msg "Entre no diretório com: cd ${DIRPKGFILE}"
	msg "Revisão manual obrigatória."
	exit 0
}

parse_config() {
	# Load global config
	set +e
	[[ -f /etc/pkgmake.conf ]] && source /etc/pkgmake.conf
	ret=$?
	set -e
	((ret == 0)) || die "erro ao carregar PKGFILE"
}

validate_config() {
	# SIGNPKG
	[[ "$SIGNPKG" =~ ^[01]$ ]] || die "SIGNPKG inválido (use 0 ou 1)"

	# VERBOSE
	[[ "$VERBOSE" =~ ^[01]$ ]] || die "VERBOSE inválido (use 0 ou 1)"

	# PACKAGER (se definido)
	if [[ -n "$PACKAGER" ]]; then
		[[ "$PACKAGER" == *"<"*">"* ]] ||
			die "PACKAGER inválido (esperado: Nome <email>)"
	fi

	# Assinatura
	if [[ "$SIGNPKG" -eq 1 ]]; then
		if [[ -n "$PRIVKEY" ]]; then
			[[ -f "$PRIVKEY" ]] ||
				die "PRIVKEY definido, mas chave não encontrada: $PRIVKEY"
		else
			find_privkey || die "SIGNPKG=1, mas nenhuma chave privada encontrada"
		fi
	fi

	#	# Contrato de build
	#	if ((!HAS_BUILD && !HAS_BUILD_STYLE)); then
	#		die "função build() ausente e nenhum build_style definido"
	#	fi

	# Contrato de instalação
	if ((!HAS_PACKAGE && !HAS_BUILD_STYLE)); then
		die "função package() ausente e nenhum build_style definido"
	fi

}

validate_pkgdest_sanity() {
	case "$PKGDEST" in
	*::* | *"//"*)
		die "PKGDEST inválido: $PKGDEST"
		;;
	esac
}

cmd_run() {
	if [[ "$VERBOSE" -eq 0 ]]; then
		"$@" >/dev/null
	else
		"$@"
	fi
	local rc=$?
	[[ $rc -eq 0 ]] || die "comando falhou: $*"
}

die() {
	echo -e "${red}erro: $*${reset}" >&2
	exit 1
}
msg() { echo -e "${cyan}==> $*${reset}"; }
warn() { echo -e "${yellow}==> aviso: $*${reset}" >&2; }
msg_error() {
	printf "${red}ERROR: %s\n" "$*" >&2
	exit 1
}

print_config() {
	cat <<EOF
# pkgmake effective configuration

PKGDEST=${PKGDEST:-"(default: ./repo)"}
PACKAGER=${PACKAGER:-"(not set)"}

SYNCDEPS=${SYNCDEPS:-0}
CLEANUP=${CLEANUP:-0}

SIGNPKG=${SIGNPKG:-0}
PRIVKEY=${PRIVKEY:-"(auto-detect)"}

REINDEX_FORCE=${REINDEX_FORCE:-1}

VERBOSE=${VERBOSE:-0}
EOF
}

gen_key() {
	[[ -f "$KEY_FILE" ]] && die "chave já existe: $KEY_FILE"

	msg "Gerando chave RSA 4096 bits (PEM): $KEY_FILE"
	cmd_run ssh-keygen -t rsa -b 4096 -m PEM -f "$KEY_FILE"

	msg "Chave gerada com sucesso:"
	msg "  $KEY_FILE"
}

normalize_dep_patterns() {
	local var i dep
	for var in depends makedepends; do
		declare -p "$var" &>/dev/null || continue
		declare -n arr="$var"
		for i in "${!arr[@]}"; do
			dep="${arr[$i]}"
			# se NÃO contém operador de versão (<, > ou =), adiciona >=0
			if ! [[ "$dep" =~ [\<\>\=] ]]; then
				arr[$i]="${dep}>=0"
			fi
		done
	done
}

normalize_deps() {
	# depends
	if declare -p depends &>/dev/null; then
		if [[ "$(declare -p depends)" != declare\ -a* ]]; then
			depends="${depends//$'\n'/ }"
			read -r -a depends <<<"$depends"
		fi
	else
		depends=()
	fi

	# makedepends
	if declare -p makedepends &>/dev/null; then
		if [[ "$(declare -p makedepends)" != declare\ -a* ]]; then
			makedepends="${makedepends//$'\n'/ }"
			read -r -a makedepends <<<"$makedepends"
		fi
	else
		makedepends=()
	fi
}

load_pkgfile() {
	# limpa possíveis funções herdadas do framework
	unset -f package build prepare check install post_install pre_install 2>/dev/null || true

	[[ -f "PKGFILE" ]] || die "PKGFILE não encontrado"

	# carrega PKGFILE no shell principal
	source "PKGFILE"

	# extrai SOMENTE as funções definidas no PKGFILE (shell isolado)
	PKG_FUNCS="$(
		bash -c "
      source \"PKGFILE\"
      declare -F | awk '{print \$3}'
    "
	)"
}

pkg_has_fn() {
	grep -qx "$1" <<<"$PKG_FUNCS"
}

lint() {
	# build(): NÃO é obrigatória
	# só falha se NÃO houver build() E NÃO houver build_style
	if ! pkg_has_fn build && [[ -z "${build_style:-}" ]]; then
		: # ok, pode não ter build
	fi

	# aceita build_style no lugar de package()
	if ! pkg_has_fn package && [[ -z "${build_style:-}" ]]; then
		die "função package() ausente"
	fi

	# Detecta PKGFILE que apaga o source (incompatível com pkgmake)
	if grep -Eq 'rm[[:space:]]+-rf[[:space:]]+(\$|\$\{)(_pkgsrc|srcdir|pkgbase)|rm[[:space:]]+-rf[[:space:]]+["'"'"']?\$\{?pkgbase\}?-\$\{?pkgver\}?' "PKGFILE"; then
		die "PKGFILE inválido: não use 'rm -rf' no diretório de source (incompatível com pkgmake)"
	fi
}

strip_dep_op() {
	local d="$1"
	d="${d%%>=*}"
	d="${d%%<=*}"
	d="${d%%=*}"
	echo "$d"
}

sync_deps() {
	[[ "$SYNCDEPS" -eq 1 ]] || return 0

	local pkgs=()
	[[ -n "${makedepends[*]}" ]] && pkgs+=("${makedepends[@]}")
	[[ -n "${depends[*]}" ]] && pkgs+=("${depends[@]}")
	[[ "${#pkgs[@]}" -eq 0 ]] && return 0

	local clean=()
	for d in "${pkgs[@]}"; do
		clean+=("$(strip_dep_op "$d")")
	done

	cmd_run sudo xbps-install -Sy "${clean[@]}"
}

fetch() {
	msg "Fetch source"
	mkdir -p "$SRCDIR"
	cd "$SRCDIR"

	for src in "${source[@]}"; do
		# alias::source
		if [[ "$src" == *::* ]]; then
			name="${src%%::*}"
			s="${src#*::}"
		else
			name=""
			s="$src"
		fi

		case "$s" in
		git+*)
			repo="${s#git+}"

			tag=""
			if [[ "$repo" == *#tag=* ]]; then
				tag="${repo##*#tag=}"
				repo="${repo%%#tag=*}"
			fi

			# se não tiver alias, usa basename
			[[ -z "$name" ]] && name="$(basename "$repo" .git)"

			if [[ -d "$name/.git" ]]; then
				msg "Usando repositório git existente: $name"
			else
				msg "Fetching: ${yellow}$s${rst}"
				cmd_run git clone "$repo" "$name" || die "falha ao clonar $repo"
			fi

			if [[ -n "$tag" ]]; then
				cmd_run git -C "$name" checkout "$tag" || die "falha ao fazer checkout do tag $tag"
			fi
			;;
		http://* | https://*)
			f="${s##*/}"
			if [[ -f "$f" ]]; then
				msg "Source já existe, usando cache: $f"
			else
				msg "Fetching: ${yellow}$s${rst}"
				if ! curl -fL --output "./$f" -- "$s"; then
					case "$f" in
					*.asc | *.sig)
						warn "assinatura não encontrada ($f), ignorando"
						;;
					*)
						die "falha ao baixar source obrigatório: $f"
						;;
					esac
				fi
			fi
			;;
		*)
			[[ -f "$WORKDIR/$s" ]] || die "arquivo local não encontrado: $s"
			cp -f "$WORKDIR/$s" .
			;;
		esac
	done
}

extract() {
	msg "Extract source"
	cd "$SRCDIR"

	local extracted=0
	shopt -s nullglob

	for f in *.tar *.tar.gz *.tgz *.tar.xz *.tar.bz2 *.tar.zst; do
		case "$f" in
		*.tar.gz | *.tgz)
			cmd_run tar -xzf "$f" && extracted=1 || die "falha ao extrair $f"
			;;
		*.tar.xz)
			cmd_run tar -xJf "$f" && extracted=1 || die "falha ao extrair $f"
			;;
		*.tar.bz2)
			cmd_run tar -xjf "$f" && extracted=1 || die "falha ao extrair $f"
			;;
		*.tar.zst)
			cmd_run tar --zstd -xf "$f" && extracted=1 || die "falha ao extrair $f"
			;;
		*.tar)
			cmd_run tar -xf "$f" && extracted=1 || die "falha ao extrair $f"
			;;
		esac
	done

	shopt -u nullglob

	if [[ "$HAS_GIT_SOURCE" -eq 1 ]]; then
		msg "Fonte VCS detectada, pulando extração de tarball"
		return 0
	fi

	# se tiver fonte git, não exige tarball
	((extracted)) || [[ "$HAS_GIT_SOURCE" -eq 1 ]] || die "nenhum tarball foi extraído"
}

detect_src() {
	local d

	d="$(find "$SRCDIR" -mindepth 1 -maxdepth 1 -type d | head -n1)"
	[[ -n "$d" ]] || die "diretório source não encontrado após extração"

	export srcdir="$SRCDIR"
	export _pkgsrc="$d"
	export wrksrc="$d"

	# compatibilidade total: Arch (pkgdir) == Void (DESTDIR)
	export pkgdir="$PKGDIR"
	export DESTDIR="$PKGDIR"
}

find_privkey() {
	[[ -n "$PRIVKEY" ]] && return 0
	for k in "$HOME/.gnupg/privkey.pem" "$HOME/.gnupg/private.pem"; do
		[[ -f "$k" ]] && {
			PRIVKEY="$k"
			return 0
		}
	done
	die "chave privada não encontrada"
}

run_all() {
	if [[ "$GEN_KEY" -eq 1 ]]; then
		gen_key
		exit 0
	fi

	if ((SIGN_ONLY)); then
		sign_only
		create_repodata
		exit 0
	fi

	msg "Lint"
	lint

	sync_deps

	fetch
	extract
	detect_src

	# estilo makepkg/xbps-src: cwd em srcdir
	cd "$srcdir" || die "falha ao entrar em srcdir"

	if pkg_has_fn prepare; then
		msg "Prepare"
		prepare
	fi

	# Build
	if pkg_has_fn build; then
		build
	elif [[ -n "${build_style:-}" ]]; then
		do_build_style
	else
		: # build é opcional
	fi

	# staging único e seguro (Arch + Void)
	mkdir -p "$DESTDIR"
	[[ -n "$DESTDIR" && "$DESTDIR" != "/" ]] || die "DESTDIR inválido"

	if pkg_has_fn pre_install; then
		msg "Package (pre-install)"
		pre_install
	fi

	#   # Package / Install
	#   if declare -f package >/dev/null; then
	#     package
	#   elif [[ -n "${build_style:-}" ]]; then
	#     do_install_style
	#   else
	#     die "função package() ausente"
	#   fi

	if ((HAS_PACKAGE)); then
		msg "Package"
		# pacote controla o install
		package
	elif [[ -n "${build_style:-}" ]]; then
		# install padrão do style (gnu-configure aqui)
		msg "Package (fakeroot)"
		command -v fakeroot >/dev/null 2>&1 || die "fakeroot não encontrado"
		fakeroot make install DESTDIR="$DESTDIR" docdir=/usr/share/doc
	else
		die "nenhuma função de install encontrada"
	fi

	# Post_install
	if pkg_has_fn post_install; then
		msg "Package (post-install)"
		post_install
	fi

	#   for d in "${depends[@]}"; do
	#    pkg="${d%%[<>=]*}"
	#    xbps-query -R -p pkgname "$pkg" >/dev/null || die "dependência inválida ou inexistente: $d"
	#   done

	# depends já é array aqui (graças ao normalize_deps)
	deps_list="${depends[*]}"

	INSTALL_OPTS=()
	if [[ -f "$WORKDIR/INSTALL" ]]; then
		INSTALL_OPTS+=(-S "$WORKDIR/INSTALL")
	fi

	msg "Create XBPS"
	cmd_run xbps-create \
		-A "$ARCH" \
		-n "${pkgname}-${pkgver}_${pkgrel}" \
		-s "$pkgdesc" \
		-l "$license" \
		-D "$deps_list" \
		"${INSTALL_OPTS[@]}" \
		"$pkgdir"

	PKGOUT="${pkgname}-${pkgver}_${pkgrel}.${ARCH}.xbps"
	mv -f "$PKGOUT" "$PKGDEST/"

	if ((SIGNPKG)); then
		sign_only
	fi

	create_repodata

	if [ "$INSTALLPKG" -eq 1 ]; then
		msg "Install package"
		if [[ "$FORCEPKG" -eq 1 ]]; then
			sudo xbps-install -R "$PKGDEST" -S -f "$pkgname"
		else
			sudo xbps-install -R "$PKGDEST" -S "$pkgname"
		fi
	else
		msg "Install with: ${yellow}sudo xbps-install -R $PKGDEST -S ${pkgname}${rst}"
	fi
}

# dispatcher mínimo para build_style
do_build_style() {
	case "$build_style" in
	gnu-configure)
		do_build_gnu_configure
		;;
	*)
		die "build_style não suportado: $build_style"
		;;
	esac
}

################################################################################################################
# HELPERS PARA VOID
################################################################################################################
vsconf() {
	local f="$1"

	[[ -f "$f" ]] || die "vsconf: arquivo '$f' não encontrado"
	install -Dm644 "$f" "$DESTDIR/etc/$(basename "$f")"

	# registra como conffile
	conf_files+=" /etc/$(basename "$f")"
}

vlicense() {
	local f

	for f in "$@"; do
		if [ ! -f "$f" ]; then
			msg_error "$pkgname: license file '$f' does not exist\n"
		fi

		install -Dm644 "$f" \
			"$DESTDIR/usr/share/licenses/$pkgname/$(basename "$f")"
	done
}

################################################################################################################

do_install_style() {
	case "$build_style" in
	gnu-configure)
		do_install_gnu_configure
		;;
	*)
		die "build_style não suportado: $build_style"
		;;
	esac
}

do_build_gnu_configure() {
	: "${configure_args:=}"
	: "${make_cmd_args:=}"

	cd "$wrksrc" || die "não foi possível entrar em Swrksrc"

	./configure \
		--prefix=/usr \
		--sysconfdir=/etc \
		--libdir=/usr/lib \
		--mandir=/usr/share/man \
		--infodir=/usr/share/info \
		$configure_args

	make $make_cmd_args
}

do_install_gnu_configure() {
	cd "$wrksrc" || die "não foi possível entrar em Swrksrc"
	make DESTDIR="$PKGDEST" install
}

clean() {
	rm -rf "$SRCDIR" "$PKGDIR" "$PKGDEST"
}

usage() {
	printf "%b\n" \
		"${bold_blue}pkgmake${reset} — utilitário de build para pacotes XBPS

${bold}Uso:${reset}
  pkgmake [opções]

${bold}Opções:${reset}
  ${green}-s${reset}, ${green}--syncdeps${reset}                 Instalar depends e makedepends
  ${green}-i${reset}, ${green}--install${reset}                  Instalar pacote após o build
  ${green}-f${reset}, ${green}--force${reset}                    Forçar reinstalação do pacote
  ${green}-q${reset}, ${green}--quiet${reset}                    Silenciar saída dos comandos
  ${green}-v${reset}, ${green}--verbose${reset}                  Mostrar saída dos comandos
      ${green}--sign${reset}                     Assinar pacote após o build
      ${green}--sign-only${reset}                Somente assinar pacotes existentes no repo
      ${green}--privkey${reset} ${yellow}<path>${reset}           Caminho da chave privada PEM (autodetecta se omitido)
      ${green}--gen-key${reset}                  Gerar chave RSA 4096 em formato PEM
  ${green}-c|--clean${reset}                     Limpar diretórios de trabalho
  ${green}-p|--print-config${reset}              Imprimir configuracao do /etc/pkgmake.conf
  ${green}-k|--pkgdest${reset} ${yellow}<path>${reset}            Diretório local onde os pacotes (.xbps) e o repodata serão gerados
  ${green}new ${yellow}<nome>${reset}                     Criar esqueleto básico de PKGFILE
  ${green}new --from-arch ${yellow}<nome>${reset}         Importar PKGBUILD do Arch/AUR (requer revisão manual)
  ${green}new --from-voidlinuxbr ${yellow}<nome>${reset}  Importar template de pacote da Comunidade VoidLinuxBR (requer revisão manual)
  ${green}new --from-void ${yellow}<nome>${reset}         Importar template de pacote do Void Linux (requer revisão manual)
  ${green}-h${reset}, ${green}--help${reset}                     Mostrar este ajuda

${bold}Exemplos:${reset}
  pkgmake
  pkgmake -s -i
  pkgmake --sign
  pkgmake --sign-only --privkey minha-chave.pem
  pkgmake -q
  pkgmake new nano
"
}

create_repodataOLD() {
	msg "Recreate repodata : $PKGDEST/x86_64-repodata"
	cmd_run xbps-rindex -r "$PKGDEST"
	cmd_run xbps-rindex -a "$PKGDEST"/*.xbps
}

create_repodata() {
	msg "Recreate repodata (hard reset)"

	# remove TODO estado antigo
	rm -f "$PKGDEST"/*-repodata

	# recria índice vazio
	cmd_run xbps-rindex -r "$PKGDEST"

	# adiciona pacotes UM A UM (igual xbps-src)
	local p
	for p in "$PKGDEST"/*.xbps; do
		[[ -f "$p" ]] || continue
		cmd_run xbps-rindex -a "$p"
	done

	# assina o índice (se habilitado)
	if [[ "$SIGNPKG" -eq 1 ]]; then
		if [[ -n "$PRIVKEY" ]]; then
			if [[ ! -f "$PRIVKEY" ]]; then
				die "PRIVKEY definido, mas chave não encontrada: $PRIVKEY"
			fi
		else
			find_privkey || die "Nenhuma chave privada encontrada para assinatura"
		fi

		local signedby=()
		[[ -n "$PACKAGER" ]] && signedby=(--signedby "$PACKAGER")

		cmd_run xbps-rindex \
			--sign \
			"${signedby[@]}" \
			--privkey "$PRIVKEY" \
			"$PKGDEST"
	fi
}

sign_only() {
	if [[ -n "$PRIVKEY" ]]; then
		[[ ! -f "$PRIVKEY" ]] && die "PRIVKEY definido, mas chave não encontrada: $PRIVKEY"
	else
		find_privkey || die "Nenhuma chave privada encontrada para assinatura"
	fi

	shopt -s nullglob
	local pkgs=("$PKGDEST"/*.xbps)
	shopt -u nullglob

	[[ "${#pkgs[@]}" -gt 0 ]] || die "nenhum pacote .xbps encontrado em $PKGDEST"

	for pkg in "${pkgs[@]}"; do
		msg "Sign package: $(basename "$pkg")"
		rm -f "$pkg.sig2"
		cmd_run xbps-rindex --sign-pkg --privkey "$PRIVKEY" "$pkg"
	done
}

resolve_fns() {
	# ---- wrappers (somente se o PKGFILE NÃO definiu a função) ----

	# prepare
	if ! pkg_has_fn prepare && pkg_has_fn do_prepare; then
		prepare() { do_prepare "$@"; }
	fi

	# build
	if ! pkg_has_fn build && pkg_has_fn do_build; then
		build() { do_build "$@"; }
	fi

	# package / install
	if ! pkg_has_fn package && pkg_has_fn do_install; then
		package() { do_install "$@"; }
	fi

	# ---- estado final (baseado NO PKGFILE) ----
	HAS_PREPARE=0
	HAS_BUILD=0
	HAS_PACKAGE=0
	HAS_BUILD_STYLE=0

	pkg_has_fn prepare && HAS_PREPARE=1
	pkg_has_fn build && HAS_BUILD=1
	pkg_has_fn package && HAS_PACKAGE=1

	[[ -n "$build_style" ]] && HAS_BUILD_STYLE=1 || true
}

resolve_pkgdest() {
	local dest

	if [[ -n "$CLI_PKGDEST" ]]; then
		dest="$CLI_PKGDEST"
	elif [[ -n "$PKGDEST" ]]; then
		dest="$PKGDEST"
	else
		die "PKGDEST não definido (use --pkgdest ou /etc/pkgmake.conf)"
	fi

	validate_pkgdest_sanity

	# absolutiza
	dest="$(readlink -f "$dest" 2>/dev/null || true)"
	[[ -n "$dest" ]] || die "PKGDEST inválido após resolução"

	# cria se não existir
	mkdir -p "$dest" || die "não consegui criar PKGDEST: $dest"

	# testa escrita
	[[ -w "$dest" ]] || die "sem permissão de escrita em PKGDEST: $dest"

	PKGDEST="$dest"
}

resolve_signpkg() {
	if [[ -n "$CLI_SIGNPKG" ]]; then
		SIGNPKG="$CLI_SIGNPKG"
	fi

	case "$SIGNPKG" in
	0 | 1) : ;;
	*)
		die "SIGNPKG inválido (use 0 ou 1): $SIGNPKG"
		;;
	esac
}

resolve_syncdeps() {
	if [[ -n "$CLI_SYNCDEPS" ]]; then
		SYNCDEPS=1
	elif [[ -z "$SYNCDEPS" ]]; then
		SYNCDEPS=0
	fi
}

resolve_verbose() {
	if [[ -n "$CLI_VERBOSE" ]]; then
		VERBOSE="$CLI_VERBOSE"
	fi

	case "$VERBOSE" in
	0 | 1) : ;;
	*)
		die "VERBOSE inválido (use 0 ou 1): $VERBOSE"
		;;
	esac
}

resolve_sources() {
	HAS_GIT_SOURCE=0

	for s in "${source[@]}"; do
		[[ "$s" == *git+* ]] && HAS_GIT_SOURCE=1 || true
	done
}

sanitize_pkgfile_vars() {
	# ---- nome do pacote ----
	: "${pkgname:?pkgname não definido no PKGFILE}"
	pkgbase="${pkgbase:-$pkgname}"

	# ---- versão / revisão (Void → Arch) ----
	if [[ -z "${pkgver:-}" && -n "${version:-}" ]]; then
		pkgver="$version"
	fi

	if [[ -z "${pkgrel:-}" && -n "${revision:-}" ]]; then
		pkgrel="$revision"
	fi

	: "${pkgver:=}"
	: "${pkgrel:=}"

	# ---- descrição (Void → Arch) ----
	if [[ -z "${pkgdesc:-}" && -n "${short_desc:-}" ]]; then
		pkgdesc="$short_desc"
	fi
	: "${pkgdesc:=}"

	# ---- source / distfiles (Void → Arch) ----
	if [[ -z "${source:-}" && -n "${distfiles:-}" ]]; then
		source="$distfiles"
	fi

	# garantir array
	if [[ -z "${source:-}" ]]; then
		source=()
	elif [[ "$(declare -p source 2>/dev/null)" != "declare -a"* ]]; then
		source=("$source")
	fi

	# ---- arrays canônicos ----
	: "${depends:=()}"
	: "${makedepends:=()}"
	: "${license:=()}"
}

if [[ "$1" == "new" ]]; then
	shift
	pkgmake_new "$@"
	exit 0
fi

while [[ $# -gt 0 ]]; do
	case "$1" in
	-s | --syncdeps)
		CLI_SYNCDEPS=1
		shift
		;;
	-i | --install)
		INSTALLPKG=1
		shift
		;;
	-f | --force)
		FORCEPKG=1
		shift
		;;
	-v | --verbose)
		CLI_VERBOSE=1
		shift
		;;
	-q | --quiet)
		CLI_VERBOSE=0
		shift
		;;
	--gen-key)
		GEN_KEY=1
		shift
		;;
	--sign)
		CLI_SIGNPKG=1
		shift
		;;
	--sign-only)
		SIGN_ONLY=1
		shift
		;;
	--privkey)
		PRIVKEY="$2"
		shift 2
		;;
	-c | --clean)
		clean
		exit 0
		;;
	-p | --print-config)
		print_config
		exit 0
		;;
	-k | --pkgdest)
		CLI_PKGDEST="$2"
		shift 2
		;;
	-h | --help)
		usage
		exit 0
		;;
	*) die "opção inválida: $1" ;;
	esac
done

parse_config
if ! ((SIGN_ONLY)); then
	resolve_syncdeps
	resolve_signpkg
	resolve_verbose
	resolve_pkgdest # blindagem de path + permissão (ANTES de tudo)
	load_pkgfile
	sanitize_pkgfile_vars
	resolve_sources
	normalize_deps
	normalize_dep_patterns
	resolve_fns
	validate_config # validação FINAL, com tudo resolvido
	sync_deps
fi
run_all
