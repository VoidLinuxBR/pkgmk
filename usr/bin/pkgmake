#!/usr/bin/env bash
# -*- coding: utf-8 -*-
# shellcheck shell=bash disable=SC1091,SC2039,SC2166,SC2034
#
#  pkgmake — makepkg-like tool for XBPS
#  Created: dom 21 dez 2025 11:47:51 -04
#  Altered: dom 21 dez 2025 11:47:51 -04
#  Updated: dom 21 dez 2025 11:47:51 -04
#
#  Copyright (c) 2019-2025, Vilmar Catafesta <vcatafesta@gmail.com>
#  Assembled By Vilmar Catafesta for the ChiliLinux project.
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY Vilmar Catafesta ''AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##############################################################################
#export LANGUAGE=pt_BR
export TEXTDOMAINDIR=/usr/share/locale
export TEXTDOMAIN=pkgmake

#debug
export PS4='${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset}'
#set -x
set -e

#system
declare APP="${0##*/}"
declare _VERSION_="0.12.21-20251221"
declare APPDESC="$APP - Wraper for xbps-create"
declare distro="$(uname -n)"
declare DEPENDENCIES=(tput)

WORKDIR="$PWD"
SRCDIR="$WORKDIR/src"
PKGDIR="$WORKDIR/pkg"
ARCH="$(uname -m)"

SYNCDEPS=0
CLI_SYNCDEPS=""
INSTALLPKG=0
FORCEPKG=0
PRIVKEY=""
SIGNPKG=0
CLI_SIGNPKG=""
SIGN_ONLY=0
VERBOSE=0
CLI_VERBOSE=""
GEN_KEY=0
KEY_FILE="privkey.pem"
PRINTCONFIG=0
PKGDEST=""
CLI_PKGDEST=""

# ANSI colors
reset='\033[0m'
black='\033[0;30m'
red='\033[0;31m'
green='\033[0;32m'
yellow='\033[0;33m'
blue='\033[0;34m'
magenta='\033[0;35m'
cyan='\033[0;36m'
white='\033[0;37m'
bold='\033[1m'

validate_pkgname() {
	local name="$1"

	[[ -z "$name" ]] && return 1

	if [[ ! "$name" =~ ^[A-Za-z0-9][A-Za-z0-9._-]*$ ]]; then
		return 1
	fi

	return 0
}

pkgmake_new() {
	# pkgmake new — create PKGFILE skeleton or import from Arch/Void
	local PKGNAME=""
	local MODE="skeleton"

	# -------- argumentos --------
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--from-arch)
			MODE="arch"
			shift
			;;
		--from-voidlinuxbr)
			MODE="voidlinuxbr"
			shift
			;;
		--from-void)
			MODE="void"
			shift
			;;
		-*)
			die "opção inválida: $1"
			;;
		*)
			PKGNAME="$1"
			shift
			;;
		esac
	done

	[[ -z "$PKGNAME" ]] &&
		die "nome do pacote não informado"

	validate_pkgname "$PKGNAME" ||
		die "nome de pacote inválido: '$PKGNAME' (use apenas letras, números, '.', '_' ou '-')"

	[[ -e "$PKGNAME" ]] &&
		die "diretório '$PKGNAME' já existe"

	case "$MODE" in
	arch)
		from_arch "$PKGNAME"
		;;
	voidlinuxbr)
		from_voidlinuxbr "$PKGNAME"
		;;
	void)
		from_void "$PKGNAME"
		;;
	skeleton)
		from_skeleton "$PKGNAME"
		;;
	*)
		die "modo interno inválido"
		;;
	esac
}

from_skeleton() {
	local PKGNAME="$1"

	mkdir -p "$PKGNAME/files" || die "não foi possível criar diretório '$PKGNAME'"
	cd "$PKGNAME" || die "não foi possível entrar no diretório '$PKGNAME'"

	cat >PKGFILE <<EOF
#!/usr/bin/env bash
# Maintainer: $(whoami)
#
# PKGFILE skeleton
# Generated by pkgmake new
#
# NOTE: This PKGFILE MUST be reviewed and completed before use

pkgname=$PKGNAME
pkgver=0.1.0
pkgrel=1
pkgdesc=""
license=()
homepage=""
depends=()
makedepends=()
distfiles=()
checksum=()

prepare() {
  :
}

build() {
  :
}

package() {
  :
}
EOF

	cd - >/dev/null || true

	msg "PKGFILE criado com sucesso."
	msg "Diretório '$PKGNAME/files' criado para patches ou arquivos auxiliares."
	msg "Entre no diretório com: cd $PKGNAME"
	msg "Revisão manual obrigatória."
}

from_voidlinuxbr() {
	local PKGNAME="$1"
	local REPO_URL="https://raw.githubusercontent.com/voidlinuxbr/pkgmake/main"
	local TMP
	TMP="$(mktemp -d)"

	msg "Importando template VoidLinuxBR: $PKGNAME"
	msg "Fonte: https://github.com/voidlinuxbr/pkgmake"

	# Escolhe downloader
	if command -v curl >/dev/null 2>&1; then
		DL="curl -fsSL"
	elif command -v wget >/dev/null 2>&1; then
		DL="wget -qO-"
	else
		die "necessário 'curl' ou 'wget' para download"
	fi

	# Baixa template do VoidLinuxBR
	if ! $DL "$REPO_URL/templates/$PKGNAME/PKGFILE" >"$TMP/PKGFILE" 2>/dev/null; then
		rm -rf "$TMP"
		die "template VoidLinuxBR não encontrado para pacote '$PKGNAME'"
	fi

	# Cria diretório do pacote
	mkdir -p "$PKGNAME"
	cd "$PKGNAME" || die "não foi possível entrar no diretório '$PKGNAME'"

	# Gera PKGFILE com aviso explícito
	{
		cat "$TMP/PKGFILE"
	} >PKGFILE

	cd - >/dev/null || true
	rm -rf "$TMP"

	msg "PKGFILE criado com sucesso."
	msg "Entre no diretório com: cd $PKGNAME"
	msg "Revisão manual obrigatória."
}

# -------------------------------------------------------------------
# new --from-arch <pkgname>
# Importa template oficial do Arch Linux
# -------------------------------------------------------------------
from_arch() {
	local PKGNAME="$1"
	mkdir -p "$PKGNAME/files"
	cd "$PKGNAME"

	msg "Fetch PKGBUILD from Arch/AUR"

	TMP="$(mktemp -d)"
	trap 'rm -rf "$TMP"' EXIT

	if ! curl -fsSL \
		"https://gitlab.archlinux.org/archlinux/packaging/packages/$PKGNAME/-/raw/main/PKGBUILD" \
		-o "$TMP/PKGBUILD"; then
		curl -fsSL \
			"https://aur.archlinux.org/cgit/aur.git/plain/PKGBUILD?h=$PKGNAME" \
			-o "$TMP/PKGBUILD" || die "PKGBUILD não encontrado"
	fi

	# -------------------------------------------------
	# GERA PKGFILE (SEM MUTILAR source)
	# -------------------------------------------------
	{
		echo "#!/usr/bin/env bash"
		echo "# NOTE: Imported from Arch PKGBUILD"
		echo "# NOTE: This PKGFILE is PARTIAL and MUST be reviewed"
		echo

		# remove linhas que quebram execução fora do makepkg
		sed \
			-e '/^pkgbase=/d' \
			-e '/^validpgpkeys=/d' \
			-e '/^_.*=/d' \
			"$TMP/PKGBUILD"
	} >PKGFILE
	msg "PKGFILE criado com sucesso."
	msg "Entre no diretório com: cd $PKGNAME"
	msg "Revisão manual obrigatória."
	exit 0
}

# -------------------------------------------------------------------
# new --from-void <pkgname>
# Importa template oficial do Void Linux (void-packages)
# -------------------------------------------------------------------
from_void() {
	local pkg="$1"
	local VOID_REPO="https://raw.githubusercontent.com/void-linux/void-packages/master"
	local TMP
	TMP="$(mktemp -d)"

	[[ -z "$pkg" ]] && die "nome do pacote não informado"

	msg "Importando template do Void Linux: $pkg"
	msg "Fonte: void-linux/void-packages"

	# Escolhe downloader
	if command -v curl >/dev/null 2>&1; then
		DL="curl -fsSL"
	elif command -v wget >/dev/null 2>&1; then
		DL="wget -qO-"
	else
		die "necessário 'curl' ou 'wget' para download"
	fi

	# Baixa template oficial
	if ! $DL "$VOID_REPO/srcpkgs/$pkg/template" >"$TMP/template" 2>/dev/null; then
		rm -rf "$TMP"
		die "template do Void não encontrado para pacote '$pkg'"
	fi

	# Cria diretório do pacote
	mkdir -p "$pkg"
	cd "$pkg" || die "não foi possível entrar no diretório '$pkg'"

	# Gera PKGFILE com aviso explícito
	{
		echo "#!/usr/bin/env bash"
		echo "# NOTE: Imported from Void Linux official template"
		echo "# NOTE: Source: https://github.com/void-linux/void-packages"
		echo "# NOTE: This PKGFILE MUST be reviewed and adjusted before use"
		echo
		cat "$TMP/template"
	} >PKGFILE

	cd - >/dev/null || true
	rm -rf "$TMP"

	msg "PKGFILE criado com sucesso."
	msg "Entre no diretório com: cd $PKGNAME"
	msg "Revisão manual obrigatória."
	exit 0
}

parse_config() {
	# Load global config
	set +e
	[[ -f /etc/pkgmake.conf ]] && source /etc/pkgmake.conf
	ret=$?
	set -e
	((ret == 0)) || die "erro ao carregar PKGFILE"
}

validate_config() {
	# SIGNPKG
	[[ "$SIGNPKG" =~ ^[01]$ ]] || die "SIGNPKG inválido (use 0 ou 1)"

	# VERBOSE
	[[ "$VERBOSE" =~ ^[01]$ ]] || die "VERBOSE inválido (use 0 ou 1)"

	# PACKAGER (se definido)
	if [[ -n "$PACKAGER" ]]; then
		[[ "$PACKAGER" == *"<"*">"* ]] ||
			die "PACKAGER inválido (esperado: Nome <email>)"
	fi

	# Assinatura
	if [[ "$SIGNPKG" -eq 1 ]]; then
		if [[ -n "$PRIVKEY" ]]; then
			[[ -f "$PRIVKEY" ]] ||
				die "PRIVKEY definido, mas chave não encontrada: $PRIVKEY"
		else
			find_privkey || die "SIGNPKG=1, mas nenhuma chave privada encontrada"
		fi
	fi
}

validate_pkgdest_sanity() {
	case "$PKGDEST" in
	*::* | *"//"*)
		die "PKGDEST inválido: $PKGDEST"
		;;
	esac
}

cmd_run() {
	if [[ "$VERBOSE" -eq 0 ]]; then
		"$@" >/dev/null
	else
		"$@"
	fi
	local rc=$?
	[[ $rc -eq 0 ]] || die "comando falhou: $*"
}

die() {
	echo -e "${red}erro: $*${reset}" >&2
	exit 1
}
msg() { echo -e "${cyan}==> $*${reset}"; }
warn() { echo -e "${yellow}==> aviso: $*${reset}" >&2; }

print_config() {
	cat <<EOF
# pkgmake effective configuration

PKGDEST=${PKGDEST:-"(default: ./repo)"}
PACKAGER=${PACKAGER:-"(not set)"}

SYNCDEPS=${SYNCDEPS:-0}
CLEANUP=${CLEANUP:-0}

SIGNPKG=${SIGNPKG:-0}
PRIVKEY=${PRIVKEY:-"(auto-detect)"}

REINDEX_FORCE=${REINDEX_FORCE:-1}

VERBOSE=${VERBOSE:-0}
EOF
}

gen_key() {
	[[ -f "$KEY_FILE" ]] && die "chave já existe: $KEY_FILE"

	msg "Gerando chave RSA 4096 bits (PEM): $KEY_FILE"
	cmd_run ssh-keygen -t rsa -b 4096 -m PEM -f "$KEY_FILE"

	msg "Chave gerada com sucesso:"
	msg "  $KEY_FILE"
}

normalize_dep_patterns() {
	local var i dep
	for var in depends makedepends; do
		declare -p "$var" &>/dev/null || continue
		declare -n arr="$var"
		for i in "${!arr[@]}"; do
			dep="${arr[$i]}"
			# se NÃO contém operador de versão (<, > ou =), adiciona >=0
			if ! [[ "$dep" =~ [\<\>\=] ]]; then
				arr[$i]="${dep}>=0"
			fi
		done
	done
}

normalize_deps() {
	# depends
	if declare -p depends &>/dev/null; then
		if [[ "$(declare -p depends)" != declare\ -a* ]]; then
			depends="${depends//$'\n'/ }"
			read -r -a depends <<<"$depends"
		fi
	else
		depends=()
	fi

	# makedepends
	if declare -p makedepends &>/dev/null; then
		if [[ "$(declare -p makedepends)" != declare\ -a* ]]; then
			makedepends="${makedepends//$'\n'/ }"
			read -r -a makedepends <<<"$makedepends"
		fi
	else
		makedepends=()
	fi
}

load_pkgfile() {
	[[ -f PKGFILE ]] || die "PKGFILE não encontrado"
	source ./PKGFILE

	: "${pkgname:?}"
	: "${pkgver:?}"
	: "${pkgrel:?}"
	: "${pkgdesc:?}"
	: "${license:?}"

	pkgbase="${pkgbase:-$pkgname}"
	declare -p source &>/dev/null || die "source não definido"
	HAS_GIT_SOURCE=0
	for s in "${source[@]}"; do
		[[ "$s" == *git+* ]] && HAS_GIT_SOURCE=1 || true
	done
}

lint() {
	declare -f package >/dev/null || die "função package() ausente"

	# Detecta PKGFILE que apaga o source (incompatível com pkgmake)
	if grep -Eq 'rm[[:space:]]+-rf[[:space:]]+(\$|\$\{)(_pkgsrc|srcdir|pkgbase)|rm[[:space:]]+-rf[[:space:]]+["'\'']?\$\{?pkgbase\}?-\$\{?pkgver\}?' PKGFILE; then
		die "PKGFILE inválido: não use 'rm -rf' no diretório de source (incompatível com pkgmake)"
	fi
}

strip_dep_op() {
	local d="$1"
	d="${d%%>=*}"
	d="${d%%<=*}"
	d="${d%%=*}"
	echo "$d"
}

sync_deps() {
	[[ "$SYNCDEPS" -eq 1 ]] || return 0

	local pkgs=()
	[[ -n "${makedepends[*]}" ]] && pkgs+=("${makedepends[@]}")
	[[ -n "${depends[*]}" ]] && pkgs+=("${depends[@]}")
	[[ "${#pkgs[@]}" -eq 0 ]] && return 0

	local clean=()
	for d in "${pkgs[@]}"; do
		clean+=("$(strip_dep_op "$d")")
	done

	cmd_run sudo xbps-install -Sy "${clean[@]}"
}

fetch() {
	msg "Fetch source"
	mkdir -p "$SRCDIR"
	cd "$SRCDIR"

	for src in "${source[@]}"; do
		# alias::source
		if [[ "$src" == *::* ]]; then
			name="${src%%::*}"
			s="${src#*::}"
		else
			name=""
			s="$src"
		fi

		case "$s" in
		git+*)
			repo="${s#git+}"

			tag=""
			if [[ "$repo" == *#tag=* ]]; then
				tag="${repo##*#tag=}"
				repo="${repo%%#tag=*}"
			fi

			# se não tiver alias, usa basename
			[[ -z "$name" ]] && name="$(basename "$repo" .git)"

			if [[ -d "$name/.git" ]]; then
				msg "Usando repositório git existente: $name"
			else
				cmd_run git clone "$repo" "$name" || die "falha ao clonar $repo"
			fi

			if [[ -n "$tag" ]]; then
				cmd_run git -C "$name" checkout "$tag" ||
					die "falha ao fazer checkout do tag $tag"
			fi
			;;
		http://* | https://*)
			f="${s##*/}"
			if [[ -f "$f" ]]; then
				msg "Source já existe, usando cache: $f"
			else
				msg "Fetching: $s"
				if ! curl -fL --output "./$f" -- "$s"; then
					case "$f" in
					*.asc | *.sig)
						warn "assinatura não encontrada ($f), ignorando"
						;;
					*)
						die "falha ao baixar source obrigatório: $f"
						;;
					esac
				fi
			fi
			;;
		*)
			[[ -f "$WORKDIR/$s" ]] || die "arquivo local não encontrado: $s"
			cp -f "$WORKDIR/$s" .
			;;
		esac
	done
}

extract() {
	msg "Extract source"
	cd "$SRCDIR"

	local extracted=0
	shopt -s nullglob

	for f in *.tar *.tar.gz *.tgz *.tar.xz *.tar.bz2 *.tar.zst; do
		case "$f" in
		*.tar.gz | *.tgz)
			cmd_run tar -xzf "$f" && extracted=1 || die "falha ao extrair $f"
			;;
		*.tar.xz)
			cmd_run tar -xJf "$f" && extracted=1 || die "falha ao extrair $f"
			;;
		*.tar.bz2)
			cmd_run tar -xjf "$f" && extracted=1 || die "falha ao extrair $f"
			;;
		*.tar.zst)
			cmd_run tar --zstd -xf "$f" && extracted=1 || die "falha ao extrair $f"
			;;
		*.tar)
			cmd_run tar -xf "$f" && extracted=1 || die "falha ao extrair $f"
			;;
		esac
	done

	shopt -u nullglob

	if [[ "$HAS_GIT_SOURCE" -eq 1 ]]; then
		msg "Fonte VCS detectada, pulando extração de tarball"
		return 0
	fi

	# se tiver fonte git, não exige tarball
	((extracted)) || [[ "$HAS_GIT_SOURCE" -eq 1 ]] || die "nenhum tarball foi extraído"
}

detect_src() {
	local d

	d="$(find "$SRCDIR" -mindepth 1 -maxdepth 1 -type d | head -n1)"
	[[ -n "$d" ]] || die "diretório source não encontrado após extração"

	export srcdir="$SRCDIR"
	export _pkgsrc="$d"

	# compatibilidade total: Arch (pkgdir) == Void (DESTDIR)
	export pkgdir="$PKGDIR"
	export DESTDIR="$PKGDIR"
}

find_privkey() {
	[[ -n "$PRIVKEY" ]] && return 0
	for k in "$HOME/.gnupg/privkey.pem" "$HOME/.gnupg/private.pem"; do
		[[ -f "$k" ]] && {
			PRIVKEY="$k"
			return 0
		}
	done
	die "chave privada não encontrada"
}

run_all() {
	if [[ "$GEN_KEY" -eq 1 ]]; then
		gen_key
		exit 0
	fi

	if ((SIGN_ONLY)); then
		sign_only
		create_repodata
		exit 0
	fi

	msg "Lint"
	lint

	sync_deps

	fetch
	extract
	detect_src

	# estilo makepkg/xbps-src: cwd em srcdir
	cd "$srcdir" || die "falha ao entrar em srcdir"

	if declare -f prepare >/dev/null; then
		msg "Prepare"
		prepare
	fi

	if declare -f build >/dev/null; then
		msg "Build"
		build
	fi

	msg "Package"

	# staging único e seguro (Arch + Void)
	mkdir -p "$DESTDIR"
	[[ -n "$DESTDIR" && "$DESTDIR" != "/" ]] || die "DESTDIR inválido"

	package

	#   for d in "${depends[@]}"; do
	#    pkg="${d%%[<>=]*}"
	#    xbps-query -R -p pkgname "$pkg" >/dev/null || die "dependência inválida ou inexistente: $d"
	#   done

	# depends já é array aqui (graças ao normalize_deps)
	deps_list="${depends[*]}"

	msg "Create XBPS"
	cmd_run xbps-create \
		-A "$ARCH" \
		-n "${pkgname}-${pkgver}_${pkgrel}" \
		-s "$pkgdesc" \
		-l "$license" \
		-D "$deps_list" \
		"$pkgdir"

	PKGOUT="${pkgname}-${pkgver}_${pkgrel}.${ARCH}.xbps"
	mv -f "$PKGOUT" "$PKGDEST/"

	if ((SIGNPKG)); then
		sign_only
	fi

	create_repodata

	if [ "$INSTALLPKG" -eq 1 ]; then
		msg "Install package"
		if [[ "$FORCEPKG" -eq 1 ]]; then
			sudo xbps-install -R "$PKGDEST" -S -f "$pkgname"
		else
			sudo xbps-install -R "$PKGDEST" -S "$pkgname"
		fi
	else
		msg "Install with:"
		msg "  sudo xbps-install -R $PKGDEST -S ${pkgname}"
	fi

}

clean() {
	rm -rf "$SRCDIR" "$PKGDIR" "$PKGDEST"
}

usage() {
	printf "%b\n" \
		"${bold_blue}pkgmake${reset} — utilitário de build para pacotes XBPS

${bold}Uso:${reset}
  pkgmake [opções]

${bold}Opções:${reset}
  ${green}-s${reset}, ${green}--syncdeps${reset}                 Instalar depends e makedepends
  ${green}-i${reset}, ${green}--install${reset}                  Instalar pacote após o build
  ${green}-f${reset}, ${green}--force${reset}                    Forçar reinstalação do pacote
  ${green}-q${reset}, ${green}--quiet${reset}                    Silenciar saída dos comandos
  ${green}-v${reset}, ${green}--verbose${reset}                  Mostrar saída dos comandos
      ${green}--sign${reset}                     Assinar pacote após o build
      ${green}--sign-only${reset}                Somente assinar pacotes existentes no repo
      ${green}--privkey${reset} ${yellow}<path>${reset}           Caminho da chave privada PEM (autodetecta se omitido)
      ${green}--gen-key${reset}                  Gerar chave RSA 4096 em formato PEM
  ${green}-c|--clean${reset}                     Limpar diretórios de trabalho
  ${green}-p|--print-config${reset}              Imprimir configuracao do /etc/pkgmake.conf
  ${green}-k|--pkgdest${reset} ${yellow}<path>${reset}            Diretório local onde os pacotes (.xbps) e o repodata serão gerados
  ${green}new ${yellow}<nome>${reset}                     Criar esqueleto básico de PKGFILE
  ${green}new --from-arch ${yellow}<nome>${reset}         Importar PKGBUILD do Arch/AUR (requer revisão manual)
  ${green}new --from-voidlinuxbr ${yellow}<nome>${reset}  Importar template de pacote da Comunidade VoidLinuxBR (requer revisão manual)
  ${green}new --from-void ${yellow}<nome>${reset}         Importar template de pacote do Void Linux (requer revisão manual)
  ${green}-h${reset}, ${green}--help${reset}                     Mostrar este ajuda

${bold}Exemplos:${reset}
  pkgmake
  pkgmake -s -i
  pkgmake --sign
  pkgmake --sign-only --privkey minha-chave.pem
  pkgmake -q
  pkgmake new nano

"
}

create_repodataOLD() {
	msg "Recreate repodata : $PKGDEST/x86_64-repodata"
	cmd_run xbps-rindex -r "$PKGDEST"
	cmd_run xbps-rindex -a "$PKGDEST"/*.xbps
}

create_repodata() {
	msg "Recreate repodata (hard reset)"

	# remove TODO estado antigo
	rm -f "$PKGDEST"/*-repodata

	# recria índice vazio
	cmd_run xbps-rindex -r "$PKGDEST"

	# adiciona pacotes UM A UM (igual xbps-src)
	local p
	for p in "$PKGDEST"/*.xbps; do
		[[ -f "$p" ]] || continue
		cmd_run xbps-rindex -a "$p"
	done

	# assina o índice (se habilitado)
	if [[ "$SIGNPKG" -eq 1 ]]; then
		if [[ -n "$PRIVKEY" ]]; then
			if [[ ! -f "$PRIVKEY" ]]; then
				die "PRIVKEY definido, mas chave não encontrada: $PRIVKEY"
			fi
		else
			find_privkey || die "Nenhuma chave privada encontrada para assinatura"
		fi

		local signedby=()
		[[ -n "$PACKAGER" ]] && signedby=(--signedby "$PACKAGER")

		cmd_run xbps-rindex \
			--sign \
			"${signedby[@]}" \
			--privkey "$PRIVKEY" \
			"$PKGDEST"
	fi
}

sign_only() {
	if [[ -n "$PRIVKEY" ]]; then
		[[ ! -f "$PRIVKEY" ]] && die "PRIVKEY definido, mas chave não encontrada: $PRIVKEY"
	else
		find_privkey || die "Nenhuma chave privada encontrada para assinatura"
	fi

	shopt -s nullglob
	local pkgs=("$PKGDEST"/*.xbps)
	shopt -u nullglob

	[[ "${#pkgs[@]}" -gt 0 ]] || die "nenhum pacote .xbps encontrado em $PKGDEST"

	for pkg in "${pkgs[@]}"; do
		msg "Sign package: $(basename "$pkg")"
		rm -f "$pkg.sig2"
		cmd_run xbps-rindex --sign-pkg --privkey "$PRIVKEY" "$pkg"
	done
}

resolve_fns() {
	# prepare
	if ! declare -f prepare >/dev/null && declare -f do_prepare >/dev/null; then
		prepare() { do_prepare "$@"; }
	fi

	# build
	if ! declare -f build >/dev/null && declare -f do_build >/dev/null; then
		build() { do_build "$@"; }
	fi

	# package / install
	if ! declare -f package >/dev/null && declare -f do_install >/dev/null; then
		package() { do_install "$@"; }
	fi
}

resolve_pkgdest() {
	local dest

	if [[ -n "$CLI_PKGDEST" ]]; then
		dest="$CLI_PKGDEST"
	elif [[ -n "$PKGDEST" ]]; then
		dest="$PKGDEST"
	else
		die "PKGDEST não definido (use --pkgdest ou /etc/pkgmake.conf)"
	fi

	validate_pkgdest_sanity

	# absolutiza
	dest="$(readlink -f "$dest" 2>/dev/null || true)"
	[[ -n "$dest" ]] || die "PKGDEST inválido após resolução"

	# cria se não existir
	mkdir -p "$dest" || die "não consegui criar PKGDEST: $dest"

	# testa escrita
	[[ -w "$dest" ]] || die "sem permissão de escrita em PKGDEST: $dest"

	PKGDEST="$dest"
}

resolve_signpkg() {
	if [[ -n "$CLI_SIGNPKG" ]]; then
		SIGNPKG="$CLI_SIGNPKG"
	fi

	case "$SIGNPKG" in
	0 | 1) : ;;
	*)
		die "SIGNPKG inválido (use 0 ou 1): $SIGNPKG"
		;;
	esac
}

resolve_syncdeps() {
	if [[ -n "$CLI_SYNCDEPS" ]]; then
		SYNCDEPS=1
	elif [[ -z "$SYNCDEPS" ]]; then
		SYNCDEPS=0
	fi
}

resolve_verbose() {
	if [[ -n "$CLI_VERBOSE" ]]; then
		VERBOSE="$CLI_VERBOSE"
	fi

	case "$VERBOSE" in
	0 | 1) : ;;
	*)
		die "VERBOSE inválido (use 0 ou 1): $VERBOSE"
		;;
	esac
}

if [[ "$1" == "new" ]]; then
	shift
	pkgmake_new "$@"
	exit 0
fi

while [[ $# -gt 0 ]]; do
	case "$1" in
	-s | --syncdeps)
		CLI_SYNCDEPS=1
		shift
		;;
	-i | --install)
		INSTALLPKG=1
		shift
		;;
	-f | --force)
		FORCEPKG=1
		shift
		;;
	-v | --verbose)
		CLI_VERBOSE=1
		shift
		;;
	-q | --quiet)
		CLI_VERBOSE=0
		shift
		;;
	--gen-key)
		GEN_KEY=1
		shift
		;;
	--sign)
		CLI_SIGNPKG=1
		shift
		;;
	--sign-only)
		SIGN_ONLY=1
		shift
		;;
	--privkey)
		PRIVKEY="$2"
		shift 2
		;;
	-c | --clean)
		clean
		exit 0
		;;
	-p | --print-config)
		print_config
		exit 0
		;;
	-k | --pkgdest)
		CLI_PKGDEST="$2"
		shift 2
		;;
	-h | --help)
		usage
		exit 0
		;;
	*) die "opção inválida: $1" ;;
	esac
done

parse_config
resolve_syncdeps
resolve_signpkg
resolve_verbose
resolve_pkgdest # blindagem de path + permissão (ANTES de tudo)
load_pkgfile
normalize_deps
normalize_dep_patterns
resolve_fns
validate_config # validação FINAL, com tudo resolvido
sync_deps
run_all
