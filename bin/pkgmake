#!/usr/bin/env bash
# pkgmake — makepkg-like tool for XBPS
# FLUXO CORRETO:
# 1) fetch   -> baixa/copias TODOS source[]
# 2) extract -> extrai SOMENTE tarballs
# 3) build   -> só roda se extraiu
# SEM apagar source em momento nenhum

# ============================================================================
# pkgmake — regras de build (IMPORTANTE)
#
# Este utilitário NÃO replica os comportamentos implícitos do makepkg.
# Em especial:
#
# 1) Os arquivos listados em source=() são baixados UMA VEZ.
#    - Se o arquivo já existir em src/, ele NÃO será baixado novamente.
#
# 2) Tarballs são extraídos UMA VEZ, antes do build.
#    - O diretório extraído NÃO será reextraído automaticamente.
#
# 3) PKGFILEs NÃO DEVEM apagar o diretório de source.
#    - NÃO use: rm -rf ${pkgbase}-${pkgver}
#    - NÃO use: rm -rf $_pkgsrc
#    - NÃO use: rm -rf "$srcdir/..."
#
#    PKGFILEs que dependem de reextração automática (como no makepkg)
#    são considerados INVÁLIDOS para o pkgmake.
#
# 4) O build SEMPRE ocorre dentro de src/<pkgname>.
#
# Resumo:
#   - Baixar ≠ extrair
#   - Extrair ≠ build
#   - pkgmake exige PKGFILEs corretos e previsíveis.
#
# ============================================================================



set -e

WORKDIR="$PWD"
SRCDIR="$WORKDIR/src"
PKGDIR="$WORKDIR/pkg"
REPODIR="$WORKDIR/repo"
ARCH="$(uname -m)"

SYNCDEPS=0
SIGNPKG=0
INSTALLPKG=0
FORCEPKG=0
PRIVKEY=""

die()  { echo "erro: $*" >&2; exit 1; }
msg()  { echo "==> $*"; }
warn() { echo "==> aviso: $*" >&2; }

load_pkgfile() {
  [[ -f PKGFILE ]] || die "PKGFILE não encontrado"
  source ./PKGFILE

  : "${pkgname:?}"
  : "${pkgver:?}"
  : "${pkgrel:?}"
  : "${pkgdesc:?}"
  : "${license:?}"

  pkgbase="${pkgbase:-$pkgname}"

  declare -p source &>/dev/null || die "source não definido"
}

lint() {
  declare -f package >/dev/null || die "função package() ausente"

  # Detecta PKGFILE que apaga o source (incompatível com pkgmake)
  if grep -Eq 'rm[[:space:]]+-rf[[:space:]]+(\$|\$\{)(_pkgsrc|srcdir|pkgbase)|rm[[:space:]]+-rf[[:space:]]+["'\'']?\$\{?pkgbase\}?-\$\{?pkgver\}?' PKGFILE; then
    die "PKGFILE inválido: não use 'rm -rf' no diretório de source (incompatível com pkgmake)"
  fi
}

sync_deps() {
  [[ "$SYNCDEPS" -eq 1 ]] || return 0
  local pkgs=()
  [[ -n "${makedepends[*]}" ]] && pkgs+=("${makedepends[@]}")
  [[ -n "${depends[*]}" ]] && pkgs+=("${depends[@]}")
  [[ "${#pkgs[@]}" -eq 0 ]] && return 0
  sudo xbps-install -Sy "${pkgs[@]}"
}

fetch() {
  msg "Fetch source"
  mkdir -p "$SRCDIR"
  cd "$SRCDIR"

  for s in "${source[@]}"; do
    s="${s#*::}"

    case "$s" in
      http://*|https://*)
        f="${s##*/}"
         if [[ -f "$f" ]]; then
           msg "Source já existe, usando cache: $f"
         else
           if ! curl -fL --output "./$f" -- "$s"; then
             case "$f" in
               *.asc|*.sig)
                 warn "assinatura não encontrada ($f), ignorando"
               ;;
               *)
                 die "falha ao baixar source obrigatório: $f"
               ;;
             esac
           fi
         fi
        ;;
      *)
        [[ -f "$WORKDIR/$s" ]] || die "arquivo local não encontrado: $s"
        cp -f "$WORKDIR/$s" .
        ;;
    esac
  done
}

extract() {
  msg "Extract source"
  cd "$SRCDIR"

  local extracted=0
  shopt -s nullglob

  for f in *.tar *.tar.gz *.tgz *.tar.xz *.tar.bz2 *.tar.zst; do
    case "$f" in
      *.tar.gz|*.tgz)
        tar -xzf "$f" && extracted=1 || die "falha ao extrair $f"
        ;;
      *.tar.xz)
        tar -xJf "$f" && extracted=1 || die "falha ao extrair $f"
        ;;
      *.tar.bz2)
        tar -xjf "$f" && extracted=1 || die "falha ao extrair $f"
        ;;
      *.tar.zst)
        tar --zstd -xf "$f" && extracted=1 || die "falha ao extrair $f"
        ;;
      *.tar)
        tar -xf "$f" && extracted=1 || die "falha ao extrair $f"
        ;;
    esac
  done
   shopt -u nullglob
  (( extracted )) || die "nenhum tarball foi extraído"
}

detect_src() {
  local d

  d="$(find "$SRCDIR" -mindepth 1 -maxdepth 1 -type d | head -n1)"
  [[ -n "$d" ]] || die "diretório source não encontrado após extração"
  export srcdir="$SRCDIR"
  export _pkgsrc="$d"
  export pkgdir="$PKGDIR"
}

find_privkey() {
  [[ -n "$PRIVKEY" ]] && return 0
  for k in "$HOME/.gnupg/privkey.pem" "$HOME/.gnupg/private.pem"; do
    [[ -f "$k" ]] && { PRIVKEY="$k"; return 0; }
  done
  die "chave privada não encontrada"
}

run_all() {
  msg "Lint"
  lint

  sync_deps

  fetch
  extract
  detect_src

  # makepkg-like: cwd é srcdir
  cd "$srcdir"

  if declare -f prepare >/dev/null; then
    msg "Prepare"
    prepare
  fi

  if declare -f build >/dev/null; then
    msg "Build"
    build
  fi

  msg "Package"
  mkdir -p "$pkgdir"
  package

  msg "Create XBPS"
  xbps-create \
    -A "$ARCH" \
    -n "${pkgname}-${pkgver}_${pkgrel}" \
    -s "$pkgdesc" \
    -l "$license" \
    "$pkgdir"

  PKGOUT="${pkgname}-${pkgver}_${pkgrel}.${ARCH}.xbps"
  mkdir -p "$REPODIR"
  mv -f "$PKGOUT" "$REPODIR/"

  if [[ "$SIGNPKG" -eq 1 ]]; then
    find_privkey
    msg "Sign package"
    xbps-rindex --sign-pkg --privkey "$PRIVKEY" "$REPODIR/$PKGOUT"
  fi

  msg "Recreate repodata"
  rm -f "$REPODIR"/*-repodata "$REPODIR"/*.sig2
  xbps-rindex -r "$REPODIR"
  xbps-rindex -a "$REPODIR"/*.xbps

  if [[ "$INSTALLPKG" -eq 1 ]]; then
    if [[ "$FORCEPKG" -eq 1 ]]; then
      sudo xbps-install -R "$REPODIR" -S -f "$pkgname"
    else
      sudo xbps-install -R "$REPODIR" -S "$pkgname"
    fi
  fi
}

clean() {
  rm -rf "$SRCDIR" "$PKGDIR" "$REPODIR"
}

usage() {
  cat <<EOF
uso: pkgmake [opções]
-s, --syncdeps
-i, --install
-f, --force
--sign
--privkey KEY
-c
EOF
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    -s|--syncdeps) SYNCDEPS=1; shift ;;
    -i|--install) INSTALLPKG=1; shift ;;
    -f|--force) FORCEPKG=1; shift ;;
    --sign) SIGNPKG=1; shift ;;
    --privkey) PRIVKEY="$2"; shift 2 ;;
    -c) clean; exit 0 ;;
    -h|--help) usage; exit 0 ;;
    *) die "opção inválida: $1" ;;
  esac
done

load_pkgfile
run_all

