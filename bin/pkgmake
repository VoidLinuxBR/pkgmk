#!/usr/bin/env bash
# pkgmake — makepkg-like tool for XBPS (Arch-compatible)

set -e

WORKDIR="$PWD"
SRCDIR="$WORKDIR/src"
PKGDIR="$WORKDIR/pkg"
REPODIR="$WORKDIR/repo"
ARCH="$(uname -m)"

SYNCDEPS=0
SIGNPKG=0
INSTALLPKG=0
FORCEPKG=0
PRIVKEY=""

die() { echo "erro: $*" >&2; exit 1; }
msg() { echo "==> $*"; }

load_pkgfile() {
  [[ -f PKGFILE ]] || die "PKGFILE não encontrado"
  source ./PKGFILE

  : "${pkgname:?}"
  : "${pkgver:?}"
  : "${pkgrel:?}"
  : "${pkgdesc:?}"
  : "${license:?}"

  if declare -p source &>/dev/null; then
    if [[ "$(declare -p source)" == "declare -a"* ]]; then
      SRC="${source[0]}"
    else
      SRC="$source"
    fi
  else
    die "source não definido"
  fi

  SRC="${SRC#*::}"
  [[ -n "$SRC" ]] || die "source vazio"
}

sync_deps() {
  [[ "$SYNCDEPS" -eq 1 ]] || return 0

  pkgs=()
  [[ -n "${makedepends[*]}" ]] && pkgs+=("${makedepends[@]}")
  [[ -n "${depends[*]}" ]] && pkgs+=("${depends[@]}")

  [[ "${#pkgs[@]}" -eq 0 ]] && return 0
  sudo xbps-install -Sy "${pkgs[@]}"
}

lint() {
  declare -f build   >/dev/null || die "função build() ausente"
  declare -f package >/dev/null || die "função package() ausente"
}

fetch() {
  mkdir -p "$SRCDIR"
  cd "$SRCDIR"

  case "$SRC" in
    git+*)
      src="${SRC#git+}"
      repo="${src%%#*}"
      ref="${src#"$repo"}"
      ref="${ref#\#}"

      msg "Clone git repository"
      rm -rf "$pkgname"
      git clone "$repo" "$pkgname"
      cd "$pkgname"

      case "$ref" in
        tag=*)    git checkout "${ref#tag=}" ;;
        commit=*) git checkout "${ref#commit=}" ;;
        branch=*) git checkout "${ref#branch=}" ;;
        "" )      : ;;
        * ) die "ref git inválida: $ref" ;;
      esac
      ;;
    *)
      file="${SRC##*/}"
      [[ -f "$file" ]] || curl -L -o "$file" "$SRC"
      tar xf "$file"
      cd "${pkgname}-${pkgver}" || die "diretório source inválido"
      ;;
  esac
}

find_privkey() {
  [[ -n "$PRIVKEY" ]] && return 0
  for k in "$HOME/.gnupg/privkey.pem" "$HOME/.gnupg/private.pem"; do
    [[ -f "$k" ]] && { PRIVKEY="$k"; return 0; }
  done
  die "chave privada não encontrada"
}

run_all() {
  msg "Lint"
  lint

  sync_deps

  msg "Fetch source"
  fetch

  if declare -f prepare >/dev/null; then
    msg "Prepare"
    prepare
  fi

  msg "Build"
  build

  msg "Package (staging)"
  mkdir -p "$PKGDIR"
  package

  msg "Create XBPS"
  xbps-create \
    -A "$ARCH" \
    -n "${pkgname}-${pkgver}_${pkgrel}" \
    -s "$pkgdesc" \
    -l "$license" \
    "$PKGDIR"

  PKGFILE_OUT="${pkgname}-${pkgver}_${pkgrel}.${ARCH}.xbps"

  mkdir -p "$REPODIR"
  mv -f "$PKGFILE_OUT" "$REPODIR/"

  if [[ "$SIGNPKG" -eq 1 ]]; then
    find_privkey
    msg "Sign package"
    xbps-rindex --sign-pkg --privkey "$PRIVKEY" "$REPODIR/$PKGFILE_OUT"
  fi

  msg "Recreate repodata (hard reset)"
  rm -f "$REPODIR"/*-repodata "$REPODIR"/*.sig2
  xbps-rindex -r "$REPODIR"
  xbps-rindex -a "$REPODIR"/*.xbps

  if [[ "$INSTALLPKG" -eq 1 ]]; then
    if [[ "$FORCEPKG" -eq 1 ]]; then
      sudo xbps-install -R "$REPODIR" -S -f "$pkgname"
    else
      sudo xbps-install -R "$REPODIR" -S "$pkgname"
    fi
  else
    msg "Install with:"
    if [[ "$FORCEPKG" -eq 1 ]]; then
      msg "  sudo xbps-install -R $REPODIR -S -f $pkgname"
    else
      msg "  sudo xbps-install -R $REPODIR -S $pkgname"
    fi
  fi
}

clean() {
  rm -rf "$SRCDIR" "$PKGDIR" "$REPODIR"
}

usage() {
  cat <<EOF
uso: pkgmake [opções]

-s, --syncdeps     instalar depends e makedepends
-i, --install      instalar pacote após build
-f, --force        forçar reinstalação
--sign             assinar pacote (.sig2)
--privkey KEY      chave RSA PEM
-c                 limpar diretórios
EOF
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    -s|--syncdeps) SYNCDEPS=1; shift ;;
    -i|--install) INSTALLPKG=1; shift ;;
    -f|--force) FORCEPKG=1; shift ;;
    --sign) SIGNPKG=1; shift ;;
    --privkey) PRIVKEY="$2"; shift 2 ;;
    -c) clean; exit 0 ;;
    -h|--help) usage; exit 0 ;;
    *) die "opção inválida: $1" ;;
  esac
done

load_pkgfile
run_all
